##### **Ques**:



Luntik came out for a morning stroll and found an array a of length n. He calculated the sum s of the elements of the array (s = ∑n i=1 ai). Luntik calls a subsequence of the array a nearly full if the sum of the numbers in that subsequence is equal to s−1.



Luntik really wants to know the number of nearly full subsequences of the array a. But he needs to come home so he asks you to solve that problem!



A sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.



###### Input:



The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. The next 2⋅t lines contain descriptions of test cases. The description of each test case consists of two lines.



The first line of each test case contains a single integer n (1 ≤ n ≤ 60) — the length of the array.



The second line contains n integers a1,a2,…,an (0 ≤ ai ≤ 10^9) — the elements of the array a.



###### Output:



For each test case print the number of nearly full subsequences of the array.





##### **Solution**:



def gcd(a, b):

&nbsp;   while b:

&nbsp;       a, b = b, a%b

&nbsp;   return a



def n\_sum(x):

&nbsp;   sum = 0

&nbsp;   for i in range(1, x+1):

&nbsp;       sum += i

&nbsp;   return sum







for \_ in range(int(input())):

&nbsp;   n = int(input())

&nbsp;   nums = list(map(int, input().split()))

&nbsp;   

&nbsp;   zero = 0

&nbsp;   one = 0

&nbsp;   res = 0



&nbsp;   for i in nums:

&nbsp;       if i==0:

&nbsp;           zero+=1

&nbsp;       elif i==1:

&nbsp;           one+=1



&nbsp;   res += one

&nbsp;   z = one\*((2\*\*zero)-1)

&nbsp;   res += z



&nbsp;   print(res)

